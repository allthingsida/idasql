/**
 * ida_metapc_itypes.hpp - x86/x64 instruction type to mnemonic mapping
 *
 * This file provides a hardcoded table mapping itype values to mnemonic strings
 * for the x86/x64 (metapc) processor module.
 *
 * To regenerate this table, run experiments/extract_allins.py inside IDA Pro
 * with an x86/x64 binary loaded.
 *
 * Usage:
 *   SELECT * FROM metapc_itypes WHERE itype = 16;
 *   SELECT i.*, m.mnemonic_name FROM instructions i
 *          LEFT JOIN metapc_itypes m ON i.itype = m.itype;
 */

#pragma once

#include "ida_vtable.hpp"
#include <sqlite3.h>

namespace idasql {
namespace metapc {

// ============================================================================
// x86/x64 Instruction Type Mapping
// ============================================================================

// Common x86/x64 instruction types (NN_* constants from allins.hpp)
// This is a subset - the full table has 1000+ entries
// Generated from ida_allins module via extract_allins.py

struct ItypeEntry {
    uint16_t itype;
    const char* name;
};

// NOTE: This table can be auto-generated by running extract_allins.py in IDA
// The entries below are common instructions as placeholders
static const ItypeEntry metapc_itype_table[] = {
    // Basic instructions (approximate values - actual values depend on IDA version)
    { 0,   "error" },       // Invalid
    { 1,   "aaa" },
    { 2,   "aad" },
    { 3,   "aam" },
    { 4,   "aas" },
    { 5,   "adc" },
    { 6,   "add" },
    { 7,   "and" },
    { 16,  "call" },        // NN_call
    { 17,  "callfi" },
    { 18,  "callni" },
    { 21,  "cmp" },
    { 56,  "jmp" },         // NN_jmp (approximate)
    { 57,  "jmpfi" },
    { 58,  "jmpni" },
    { 59,  "jmpshort" },
    { 63,  "lea" },         // NN_lea (approximate)
    { 88,  "mov" },         // NN_mov (approximate)
    { 103, "nop" },         // NN_nop (approximate)
    { 114, "pop" },         // NN_pop (approximate)
    { 117, "push" },        // NN_push (approximate)
    { 121, "ret" },         // NN_retn (approximate)
    { 134, "sub" },         // NN_sub (approximate)
    { 137, "test" },        // NN_test (approximate)
    { 142, "xor" },         // NN_xor (approximate)
    // ... add more as needed
    { 0xFFFF, nullptr }     // Sentinel
};

// Get mnemonic name for an itype value
inline const char* get_itype_name(uint16_t itype) {
    for (const auto& entry : metapc_itype_table) {
        if (entry.name == nullptr) break;
        if (entry.itype == itype) return entry.name;
    }
    return nullptr;
}

// Count of entries (excluding sentinel)
inline size_t get_itype_table_size() {
    size_t count = 0;
    for (const auto& entry : metapc_itype_table) {
        if (entry.name == nullptr) break;
        count++;
    }
    return count;
}

// ============================================================================
// Virtual Table: metapc_itypes
// ============================================================================

inline VTableDef define_metapc_itypes() {
    return table("metapc_itypes")
        .count([]() {
            return get_itype_table_size();
        })
        .column_int("itype", [](size_t i) -> int {
            if (i >= get_itype_table_size()) return 0;
            return metapc_itype_table[i].itype;
        })
        .column_text("mnemonic", [](size_t i) -> std::string {
            if (i >= get_itype_table_size()) return "";
            const char* name = metapc_itype_table[i].name;
            return name ? name : "";
        })
        .build();
}

} // namespace metapc
} // namespace idasql
